import { create } from 'zustand';
import playerStore from './playerStore';
import { PlayerNamesType } from './playerType';
import landStore from './landStore';
import { getDestinationId, keyPendingActions, positionPendingActions } from './gamePlayLogic';
import { isActionType, isDiceRolled } from './gamePlayType';
import { RollResult } from '../pages/game/hooks/useRollDice';
import { LandType } from '../utils/mapType';
import { PlayState } from './gamePlayType';
import { getRandomElement } from '../utils/utils';
import { LUCKY_KEYS } from '../data/luckyKeys';

const usePlayStore = create<PlayState>()((set, get) => ({
  gamePhase: 'ROLL',
  isRolling: false,
  dices: null,
  isDouble: false,
  pendingAction: null,
  diceIsRolled: false,
  pickedKey: null,

  setDiceIsRolled: (diceIsRolled) => {
    set({ diceIsRolled });
  },
  setPickedKey: (key) => set({ pickedKey: key }),
  setGamePhase: (phase) => set({ gamePhase: phase }),

  //Ïù¥ÎèôÏ≤òÎ¶¨ //ÏõîÍ∏âÏ≤¥ÌÅ¨Ìï¥ÏÑú Î∞õÍ∏∞ //ÏÉàÎ°úÏö¥ ÏúÑÏπò ÏÑ§Ï†ï Î∞è Î∞òÌôò
  handleMoving: async (diceResult: RollResult) => {
    const currentPlayer = playerStore.getState().getNowTurn();
    const currentPositionInfo = currentPlayer.position;
    const newPosition = (currentPositionInfo.id + diceResult.total) % 40; // Î≥¥ÎìúÏùò ÌÅ¨Í∏∞Ïóê Îî∞Îùº Ï°∞Ï†ï

    // ÏõîÍ∏â Ï≤¥ÌÅ¨
    if (newPosition < currentPositionInfo.id) {
      await playerStore.getState().processPayment(200000, currentPlayer.id);
    }

    await playerStore.getState().updatePlayerPosition(currentPlayer.id, newPosition);
    return landStore.getState().getLandInfo(newPosition);
  },

  handleGoldenKeyPick: async () => {
    //goldenKeyÎ•º ÏÑ†ÌÉùÌïòÍ≥† ÏóÖÎç∞Ïù¥Ìä∏
    const newKey = getRandomElement(LUCKY_KEYS);
    set({ pickedKey: newKey });
  },

  getGoldenKeyActionHandler: () => {
    const { pendingAction, pickedKey } = get();
    const currentPlayer = playerStore.getState().getNowTurn();

    if (!pendingAction) console.warn('pendingAction is null', pendingAction);
    if (!pickedKey) return console.warn('');
    return () =>
      get().goldenKeyHandlers[pickedKey.action.type](pickedKey, currentPlayer, pendingAction);
  },
  goldenKeyHandlers: {
    MOVE_WITH_PAYMENT: async (pickedKey, currentPlayer) => {
      if (!pickedKey || pickedKey.action.type !== 'MOVE_WITH_PAYMENT') return;

      const lands = landStore.getState().lands;
      const destinationId = getDestinationId(pickedKey.action.destination, lands, currentPlayer);
      if (!destinationId) return;

      const rentLandName = pickedKey.action.payment.paymentProperty.rentLandName;
      const rentLandId = getDestinationId(rentLandName, lands, currentPlayer);
      if (!rentLandId) return console.warn('rentLandId is undefined');
      const landsAndrentPrice = landStore
        .getState()
        .getLandOwnerAndRent(rentLandId, currentPlayer.id);

      await playerStore.getState().updatePlayerPosition(currentPlayer.id, destinationId);

      if (landsAndrentPrice && landsAndrentPrice.hasOwner && landsAndrentPrice.ownerId) {
        const { useRentPrice } = pickedKey.action.payment.paymentProperty;
        const rent = useRentPrice ? landsAndrentPrice.rentPrice : 0;
        const toId = useRentPrice ? landsAndrentPrice.ownerId : undefined;

        await playerStore.getState().processPayment(rent || 0, currentPlayer.id, toId);
      }

      // ÏõîÍ∏â Ï≤¥ÌÅ¨
      if (pickedKey.action.checkPassStart) {
        const pay = landStore.getState().calculatePayWarp(currentPlayer.position.id, destinationId);
        if (pay) {
          await playerStore.getState().processPayment(200000, currentPlayer.id);
        }
      }
    },
    RECEIVE: async (_, currentPlayer) => {
      playerStore.getState().processPayment(100000, currentPlayer.id);
    },
    PAY: async (_, currentPlayer, pendingAction) => {
      console.log('Ìô©Í∏àÏó¥Ïá† pay Ïã§Ìñâ');
      playerStore.getState().processPayment(pendingAction?.price || 0, currentPlayer.id);
    },
    BUILDING_PAYMENT: async (_, currentPlayer, pendingAction) => {
      console.log('Ìô©Í∏àÏó¥Ïá† Í±¥Î¨º ÌéòÏù¥ Ïã§Ìñâ');
      playerStore.getState().processPayment(pendingAction?.total || 0, currentPlayer.id);
    },
    SELL_BUILDING: async (_, _2, pendingAction) => {
      console.log('sell building actionÏã§Ìñâ, ');
      console.log('Ìåî Î¨ºÍ±¥', pendingAction?.target, 'ÌÉÄÏûÖ', pendingAction?.type);
    },
    MOVE: async (_, currentPlayer, pendingAction) => {
      console.log('MOVE is called');
      if (!pendingAction?.position) return console.warn('pendingAction.position is undefined');
      playerStore.getState().updatePlayerPosition(currentPlayer.id, pendingAction?.position);
    },
    WORLD_TOUR: async (_, currentPlayer, pendingAction) => {
      get().actionHandlers['FUND_RECEIVE'](pendingAction, currentPlayer);
    },
    ESCAPE: async () => {},
    FREE_PASS: async () => {},
  },

  actionHandlers: {
    BUY: async (pendingAction, currentPlayer) => {
      if (!pendingAction) return;
      try {
        const result = await playerStore
          .getState()
          .processPayment(pendingAction.price ? -pendingAction.price : 0, currentPlayer.id);

        console.log(result, 'processPayment is Fulfilled');
        if (!pendingAction?.landId) return console.warn('pendingAction.landId is undefined');

        landStore.getState().updateLandOwner(pendingAction.landId, currentPlayer.id);
        playerStore.getState().updateLandOwner(pendingAction.landId, currentPlayer.id);
      } catch (error) {
        console.error('Error during buy process:', error);
      }
    },
    PAY_RENT: async (pendingAction, currentPlayer) => {
      if (!pendingAction) return;
      if (!pendingAction.options?.owner) return console.log('owner is not exist');
      await playerStore
        .getState()
        .processPayment(
          pendingAction.price ? -pendingAction.price : 0,
          currentPlayer.id,
          pendingAction.options?.owner!,
        );
    },
    BUILD: async (pendingAction, currentPlayer, building) => {
      if (!pendingAction) return console.warn('pending action is undefined');
      console.log(building);
      if (!building) return console.warn('building is undefined');
      if (!pendingAction?.landId) return console.warn('pendingAction.landId is undefined');

      landStore.getState().updateBuildings(pendingAction.landId, building);
      playerStore.getState().constructBuilding(pendingAction.landId, currentPlayer.id, building);
    },
    SELL: async () => {
      // return new Promise((resolve) => {
      //   resolve(true);
      // });
    },
    SKIP: async () => {
      return get().handleNextTurn();
    },
    FUND_RAISE: async (pendingAction, currentPlayer, _, _2) => {
      if (!pendingAction) return;
      playerStore.getState().processPayment(-pendingAction.fund!, currentPlayer.id);
      landStore.getState().fundRaising(currentPlayer.position, pendingAction.fund!);
    },
    FUND_RECEIVE: async (pendingAction, currentPlayer, _, _2) => {
      if (!pendingAction) return;
      playerStore.getState().processPayment(pendingAction.fund || 0, currentPlayer.id);
      landStore
        .getState()
        .fundRaising(currentPlayer.position, pendingAction.fund ? -pendingAction.fund : 0);
    },

    INISLAND: async () => {
      console.log('handleUserActionÏóêÏÑúÏùò INISLAND Ìï®Ïàò Ìò∏Ï∂ú Ïù¥Îü¨Î©¥ ÏïàÎê® ÏóêÎü¨');

      return;
    },
    // GOLDEN_KEY: async () => {
    //   //Ìô©Í∏àÏó¥Ïá† ÎΩëÍ∏∞ Î∞è Í∑∏ÏóêÎî∞Î•∏ Îã§Ïùå Ïï°ÏÖò ÏÑ§Ï†ï
    //   //
    //   playerStore.getState().updateNestedPlayerInfo(currentPlayer.id, ['canSkipTurn'], true);
    //   return;
    // },
    PICK_GOLDEN_KEY: async (_, currentPlayer, _2, _3) => {
      const pickedKey = getRandomElement(LUCKY_KEYS);
      set({ pickedKey, pendingAction: null });

      const setPendingAction = get().setPendingAction;

      //keyÏóêÎî∞Î•∏ ÌéúÎî©Ïï°ÏÖò ÏÑ§Ï†ï
      keyPendingActions(pickedKey, setPendingAction, currentPlayer);
    },

    SPACE_MOVE: async (pendingAction, currentPlayer, _, warpPositionId) => {
      //Ïö∞Ï£ºÏó¨ÌñâÏùº Îïå Ïª¨ÎüºÎπÑÏïÑÌò∏ ÏÜåÏú†Ï£ºÏóêÍ≤å 20ÎßåÏõêÏßÄÍ∏â
      if (!pendingAction) return;

      if (pendingAction.options?.owner) {
        playerStore
          .getState()
          .processPayment(pendingAction.price || 0, currentPlayer.id, pendingAction.options?.owner);
      }
      //ÏõêÌïòÎäî ÏúÑÏπòÎ°ú Ïù¥Îèô
      if (warpPositionId) {
        playerStore.getState().updatePlayerPosition(currentPlayer.id, warpPositionId);
        const calculatePayWarp = landStore.getState().calculatePayWarp;
        if (calculatePayWarp(currentPlayer.position.id, warpPositionId)) {
          //ÏãúÏûëÏ†ê ÏßÄÎÇòÎ©¥ ÏõîÍ∏âÏ£ºÍ∏∞
          await playerStore.getState().processPayment(200000, currentPlayer.id);
        }
      }
    },
  },
  //ÎïÖ Íµ¨Îß§, ÏûÑÎåÄÎ£å ÏßÄÎ∂à, Í±¥Î¨º Í±¥ÏÑ§ Îì±Ïùò ÏÇ¨Ïö©Ïûê ÏÑ†ÌÉù Ï≤òÎ¶¨
  // pendingAction ÏÉÅÌÉúÏóê Îî∞Î•∏ Ï†ÅÏ†àÌïú Ïï°ÏÖò Ïã§Ìñâ
  // Ïï°ÏÖò ÏôÑÎ£å ÌõÑ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
  handleUserAction: async (actionType, building, warpPositionId) => {
    console.log('handleUserAction is called üòà', actionType);
    const { pendingAction } = get();
    const currentPlayer = playerStore.getState().getNowTurn();

    if (actionType === 'SKIP') {
      return get().handleNextTurn();
    }

    if (actionType === 'PICK_GOLDEN_KEY') {
      console.log('0 : Executing golden key action:', actionType);
      get().handleGoldenKeyPick();
      const pickedKey = get().pickedKey;

      console.log('1 : Í≥†Î•∏ goldenKey', pickedKey?.contents, pickedKey?.action.type);
      console.log('2 : goldenKey pick is success');

      const newKey = pickedKey!;
      const setPendingAction = get().setPendingAction;
      const currentPlayer = playerStore.getState().getNowTurn();

      keyPendingActions(newKey, setPendingAction, currentPlayer);
      console.log('3 : pendingAction ÏÑ§Ï†ï ÏôÑÎ£å');

      get().getGoldenKeyActionHandler();

      return;
    }

    if (!pendingAction || pendingAction.type !== actionType) {
      console.log({ pendingAction, actionType });
      console.warn('Invalid action or no pending action');
      return;
    }

    const actionFn = isActionType(actionType)
      ? () =>
          get().actionHandlers[actionType](pendingAction, currentPlayer, building, warpPositionId)
      : () => {
          const pickedKey = get().pickedKey;
          if (!pickedKey) return console.warn('picked Key is null');
          return get().goldenKeyHandlers[pickedKey.action.type](
            pickedKey,
            currentPlayer,
            pendingAction,
          );
        };

    try {
      await actionFn();

      playerStore.getState().updateNestedPlayerInfo(currentPlayer.id, ['canSkipTurn'], true);
    } catch (error) {
      console.error('Action failed:', error);
      throw error;
    }
    set({ pendingAction: null });
    if (currentPlayer.doubleTurnLeft) return;

    // get().handleNextTurn();
  },

  setPendingAction: (pendingAction) => {
    console.log('setPendingAction is called');
    set({ pendingAction });
  },

  //ÌîåÎ†àÏù¥Ïñ¥Í∞Ä ÎèÑÏ∞©Ìïú Ïπ∏Ïùò ÌÉÄÏûÖÏóê Îî∞Î•∏ Ïï°ÏÖò Ïã§Ìñâ
  // gamePlayLogic.tsÏóê Ï†ïÏùòÎêú positionPendingActions Ïã§Ìñâ
  handlePendingAction: async (position: LandType, currentPlayer: PlayerNamesType) => {
    const { setPendingAction, setGamePhase } = get();
    const { getAvailableBuildings } = landStore.getState();

    const action = positionPendingActions[position.type];
    try {
      if (action) {
        await action({
          position,
          currentPlayer,
          setPendingAction,
          setGamePhase,
          getAvailableBuildings,
        });
      }
    } catch (err) {
      throw new Error(`err ocurred, ${err}`);
    }
  },

  setDices: (dices) => {
    const currentPlayer = playerStore.getState().getNowTurn();
    playerStore.getState().updateNestedPlayerInfo(currentPlayer.id, ['canSkipTurn'], false);

    set({ dices: dices });
  },

  //ÎçîÎ∏î Ïó¨Î∂ÄÏóê Îî∞Î•∏ Ï∂îÍ∞Ä ÌÑ¥ Ï≤òÎ¶¨
  // Îã§Ïùå ÌîåÎ†àÏù¥Ïñ¥Î°ú ÌÑ¥ ÎÑòÍ∏∞Í∏∞
  // Í≤åÏûÑ ÌéòÏù¥Ï¶à Ï¥àÍ∏∞Ìôî
  handleNextTurn: () => {
    const { getNowTurn, nextTurn } = playerStore.getState();
    const currentPlayer = getNowTurn();

    nextTurn(currentPlayer);

    set({ pendingAction: null });
    set({ gamePhase: 'ROLL' });
    set({ diceIsRolled: false });
  },

  validateAndResetDice: () => {
    const { dices: diceResult, diceIsRolled } = get();

    if (!isDiceRolled(diceResult) || !diceIsRolled) {
      throw new Error('Dice must be rolled before handling turn');
    }
  },

  handleIslandTurn: async () => {
    const { updateNestedPlayerInfo, updateIslandTurn } = playerStore.getState();
    const { getNowTurn } = playerStore.getState();

    const curPlayer = getNowTurn();

    if (curPlayer.isInIsland) {
      const diceResult = get().dices;
      const diceIsRolled = get().diceIsRolled;

      if (curPlayer.islandTurnLeft === 0) {
        //islandLeftÌÑ¥ÏùÑ ÏÜåÏßÑÌïòÏó¨ ÌÉàÏ∂ú ÌÑ¥ÏûÑ

        updateNestedPlayerInfo(curPlayer.id, ['isInIsland'], false);
        updateNestedPlayerInfo(curPlayer.id, ['islandTurnLeft'], 0);
        return await get().handleMovingAndPendingAction();
      }

      //ÌÉàÏ∂úÏãú Îã§Î•∏ Ïï°ÏÖòÏúºÎ°ú ÎÑòÍ∏∞Í∏∞

      if (!isDiceRolled(diceResult) || !diceIsRolled) {
        throw new Error('Ï£ºÏÇ¨ÏúÑÎ•º Íµ¥Î†§Ï£ºÏÑ∏Ïöî');
      }

      //doubleÏùº Í≤ΩÏö∞ ÌÉàÏ∂ú
      if (diceResult.isDouble) {
        updateNestedPlayerInfo(curPlayer.id, ['isInIsland'], false);
        updateNestedPlayerInfo(curPlayer.id, ['islandTurnLeft'], 0);
        get().handleNextTurn();
      }

      if (curPlayer.islandTurnLeft === 1) {
        //1ÏùºÍ≤ΩÏö∞ Îã§ÏùåÏóê ÌÉàÏ∂úÌï®
        updateNestedPlayerInfo(curPlayer.id, ['isInIsland'], false);
      }
      if (!diceResult.isDouble) updateIslandTurn(curPlayer.id, -1);
    }

    get().handleNextTurn();
  },

  handleMovingAndPendingAction: async () => {
    const { getNowTurn } = playerStore.getState();
    const { dices: diceResult, handleMoving, handlePendingAction } = get();

    if (!diceResult) throw Error('dice result is undefined');
    const curPlayer = getNowTurn();

    const newPosition = await handleMoving(diceResult);

    if (newPosition) {
      //Î¨¥Ïù∏ÎèÑ ÏÉàÎ°ú ÏßÑÏûÖÏãú
      if (newPosition.type === 'island') {
        console.log('newPositionTypeÏù¥ islandÏûÑ!', newPosition);
        //Ìï¥Îãπ ÌîåÎ†àÏù¥Ïñ¥ isInIsland Î∞è islandTurnLeft ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        playerStore.getState().updateFirstIslandState(curPlayer.id);
        return get().handleNextTurn();
      }

      await handlePendingAction(newPosition, curPlayer);
    }
  },

  // ÌÑ¥Ïùò Ï†ÑÏ≤¥ ÌùêÎ¶ÑÏùÑ Ï†úÏñ¥ÌïòÎäî Î©îÏù∏ Î©îÏÑúÎìú
  // ÏàúÏÑú:
  // 1. Î¨¥Ïù∏ÎèÑ ÏÉÅÌÉú Ï≤¥ÌÅ¨
  // 2. Ï£ºÏÇ¨ÏúÑ Íµ¥Î¶¨Í∏∞
  // 3. ÎçîÎ∏î Ï≤òÎ¶¨
  // 4. Ïù¥Îèô Ï≤òÎ¶¨
  // 5. ÏúÑÏπò Í∏∞Î∞ò Ïï°ÏÖò Ïã§Ìñâ
  // 6. Îã§Ïùå ÌÑ¥ ÏßÑÌñâ

  handleTurn: async () => {
    const { getNowTurn, updateDouble } = playerStore.getState();
    const { dices: diceResult, validateAndResetDice } = get();
    const curPlayer = getNowTurn();

    if (!diceResult) throw Error('dice result is undefined');

    validateAndResetDice();

    // Î¨¥Ïù∏ÎèÑ Ï≤òÎ¶¨
    const escapeIslandTurn = curPlayer.islandTurnLeft === 0;
    if (curPlayer.isInIsland && !escapeIslandTurn) {
      //Í∏∞Ï°¥Ïóê islandÏóê ÏûàÎäî Í≤ΩÏö∞ (turn 2Î∂ÄÌÑ∞)
      return await get().handleIslandTurn();
    }

    // ÌÑ¥ ÏãúÏûë Ïãú ÎÇ®ÏùÄ ÎçîÎ∏î ÌÑ¥ Ï≤¥ÌÅ¨ Î∞è Ï≤òÎ¶¨
    if (diceResult && curPlayer.doubleTurnLeft) {
      updateDouble(curPlayer.id, true, -1);
    }

    // ÎçîÎ∏îÏ≤òÎ¶¨
    if (diceResult.isDouble) {
      playerStore.getState().updateNestedPlayerInfo(curPlayer.id, ['canSkipTurn'], false);
      await playerStore.getState().updateDouble(curPlayer.id, true, 1);
    }

    get().handleMovingAndPendingAction();
  },
}));

export default usePlayStore;
